#### web安全

##### CIA三元组

```
机密性（Confidentiality）
完整性（Integrity）
可用性（Availability
```

##### XSS

```
XSS(Cross-Site Scripting，跨站脚本攻击)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 cookie，session tokens，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。
因为浏览器无法区分脚本是被恶意注入的还是正常的内容，它都会执行，况且 HTML 非常灵活，可以在任何时候对它进行修改。
```

###### XSS类型

```
反射型 XSS (也叫非持久型)
反射型：顾名思义，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又将这部分返回给用户，恶意脚本在页面中被执行。一般发生在前后端一体的应用中，服务端逻辑会改变最终的网页代码。
恶意代码会放在URL里

基于 DOM 的 XSS
目前更流行前后端分离的项目，反射型 XSS 无用武之地。 但这种攻击不需要经过服务器，我们知道，网页本身的 JavaScript 也是可以改变 HTML 的，黑客正是利用这一点来实现插入恶意脚本。
由浏览器端执行恶意代码，属于前端漏洞，另外两个属于服务端漏洞

存储型 XSS (也叫持久型 XSS)
又叫持久型 XSS，顾名思义，黑客将恶意 JavaScript 脚本长期保存在服务端数据库中，用户一旦访问相关页面数据，恶意脚本就会被执行。常见于搜索、微博、社区贴吧评论等。
恶意代码放在服务器端
```

反射型

![image-20220411134237497](\image\image-20220411134237497.png)

基于DOM型

![image-20220411134346626](\image\image-20220411134346626.png)

存储型

![image-20220411134522368](\image\image-20220411134522368.png)

###### 防护方法

```
一切用户输入皆不可信，在输出时进行验证
将 HTML 元素内容、属性以及 URL 请求参数、CSS 值进行编码
当编码影响业务时，使用白名单规则进行检测和过滤
使用 W3C 提出的 CSP (Content Security Policy，内容安全策略)，定义域名白名单
设置 Cookie 的 HttpOnly 属性
```

##### CSRF

```
CSRF 英文全称是 Cross-site request forgery，又称为“跨站请求伪造”。

顾名思义，CSRF 攻击就是黑客引诱用户打开黑客的网站，利用用户的登陆状态发起跨站请求。

降维解释：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。
利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证， 达到冒充用户对被攻击的网站执行某项操作的目的。
```

###### 实现方法

```
最容易实现的是 Get 请求，一般进入黑客网站后，可以通过设置 img的 src 属性来自动发起请求
在黑客的网站中，构造隐藏表单来自动发起 Post 请求
通过引诱链接诱惑用户点击触发请求，利用 a 标签的 href。
```

###### 防范CSRF的方法

```
针对实际情况，设置关键 Cookie 的 SameSite 属性为 Strict 或 Lax
服务端验证请求来源站点(Referer、Origin) Referer并不安全可以被更改
使用 CSRF Token，服务端随机生成返回给浏览器的 Token，每一次请求都会携带不同的 CSRF Token
加入二次验证(独立的支付密码，手机验证码)
```



##### CSRF和XSS的区别

```
CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。

CSRF 攻击成本也比 XSS 低，用户每天都要访问大量网页，无法确认每一个网页的合法性， 从用户角度来说，无法彻底防止 CSRF 攻击。
```

