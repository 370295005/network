#### TCP

**TCP是一个面向连接的、可靠的、基于字节流的传输层协议。**

##### TCP三次握手

```
从最开始双方都处于CLOSED状态。然后服务端开始监听某个端口，进入了LISTEN状态。
然后客户端主动发起连接，发送 SYN , 自己变成了SYN-SENT状态。
服务端接收到，返回SYN和ACK(对应客户端发来的SYN)，自己变成了SYN-REVD。
之后客户端再发送ACK给服务端，自己变成了ESTABLISHED状态；服务端收到ACK之后，也变成了ESTABLISHED状态。

第一次客户端给服务器发: SYN 表示客户端发送能力没有问题 (client:SYN-SENT,server:LISTEN)
第二次服务器给客户端发 SYN ACK 表示服务器接收和发送能力没有问题 (client:SYN-SENT,server:SYN-RCVD)
第三次客户端给服务器发 ACK 表示客户端接收能力没有问题 (client:ESTABLISHED,server:ESTABLISHED)

第三次握手的时候可以携带数据
```

![image-20220402115016153](.\image\image-20220402115016153.png)

##### TCP四次挥手

```
初始状态：(client:ESTABLISHED, server:ESTABLISHED)
第一次:客户端向服务器发送FIN (client:FIN-WAIT-1, server:ESTABLISHED),发完之后无法向服务器发送报文了，只能接收
第二次:服务器接收后向客户端确认,发送ACK(client:FIN-WAIT-1, server:CLOSED-WAIT),客户端接收到ACK (client:FIN-WAIT-2, server:CLOSED-WAIT)
第三次:服务器像客户端发送FIN ACK  客户端收到后变为(client:TIME-WAIT, server:LAST-ACK)
第四次:客户端向服务器发送ACK 会等待两个MSL(报文最大生存时间)在这段时间内如果客户端没有收到服务端的重发请求，那么表示 ACK 成功到达，挥手结束，否则客户端重发 ACK。 (client:CLOSED,server:CLOSED)

为什么第四次的时候要等待两个MSL(大约四分钟左右)
如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。
```

![image-20220402143605029](.\image\image-20220402143605029.png)

##### 流量控制

```
对于发送端和接收端而言，TCP 需要把发送的数据放到发送缓存区, 将接收的数据放到接收缓存区。
而流量控制所要做的事情，就是在通过接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能再继续发送了。
```

###### 滑动窗口

发送窗口和接收窗口

发送窗口：

![image-20220402163752863](.\image\image-20220402163752863.png)

- 已发送且已确认
- 已发送但未确认
- 未发送但可以发送
- 未发送也不可以发送

![image-20220402163815202](.\image\image-20220402163815202.png)

SND：send WND：window UNA：unacknowledge (未被确认) NXT：next(下一个发送的位置)

接收窗口：

接收窗口是对接收端的限制

![image-20220402163932683](.\image\image-20220402163932683.png)

REV:receive  REV.NXT 表示下一个接收的位置

###### 流量控制过程

```
首先双方三次握手，初始化各自的窗口大小，均为 200 个字节。

假如当前发送端给接收端发送 100 个字节，那么此时对于发送端而言，SND.NXT 当然要右移 100 个字节，也就是说当前的可用窗口减少了 100 个字节，这很好理解。

现在这 100 个到达了接收端，被放到接收端的缓冲队列中。不过此时由于大量负载的原因，接收端处理不了这么多字节，只能处理 40 个字节，剩下的 60 个字节被留在了缓冲队列中。

注意了，此时接收端的情况是处理能力不够用啦，你发送端给我少发点，所以此时接收端的接收窗口应该缩小，具体来说，缩小 60 个字节，由 200 个字节变成了 140 字节，因为缓冲队列还有 60 个字节没被应用拿走。

因此，接收端会在 ACK 的报文首部带上缩小后的滑动窗口 140 字节，发送端对应地调整发送窗口的大小为 140 个字节。
此时对于发送端而言，已经发送且确认的部分增加 40 字节，也就是 SND.UNA 右移 40 个字节，同时发送窗口缩小为 140 个字节。

这也就是流量控制的过程。尽管回合再多，整个控制的过程和原理是一样的。

```

##### 拥塞控制

```
对于拥塞控制来说，TCP 每条连接都需要维护两个核心状态:

拥塞窗口（Congestion Window，cwnd）
慢启动阈值（Slow Start Threshold，ssthresh）

涉及到的算法有这几个:

慢启动
拥塞避免
快速重传和快速恢复
```

###### 拥塞窗口

是指目前自己还能传输的数据量大小，拥塞窗口是对发送方的限制，限制了发送窗口的大小	

```
发送窗口大小的 = min(接收窗口，拥塞窗口)
```



```
拥塞控制首先就是要采用一种保守的算法来慢慢地适应整个网路，这种算法叫慢启动。运作过程如下:
RTT(往返传输时间)
首先，三次握手，双方宣告自己的接收窗口大小
双方初始化自己的拥塞窗口(cwnd)大小
在开始传输的一段时间，发送端每收到一个 ACK，拥塞窗口大小加 1，也就是说，每经过一个 RTT，cwnd 翻倍。如果说初始窗口为 10，那么第一轮 10 个报文传完且发送端收到 ACK 后，cwnd 变为 20，第二轮变为 40，第三轮变为 80，依次类推。
直到到达慢启动阈值，之后拥塞窗口大小由拥塞避免来控制

拥塞避免

原来每收到一个 ACK，cwnd 加1，现在到达阈值了，cwnd 只能加这么一点: 1 / cwnd。那你仔细算算，一轮 RTT 下来，收到 cwnd 个 ACK, 那最后拥塞窗口的大小 cwnd 总共才增加 1。
也就是说，以前一个 RTT 下来，cwnd翻倍，现在cwnd只是增加 1 而已。
```

###### 快速重传和快速回复

快速重传：

在 TCP 传输的过程中，如果发生了丢包，即接收端发现数据段不是按序到达的时候，接收端的处理是重复发送之前的 ACK。

比如第 5 个包丢了，即使第 6、7 个包到达了接收端，接收端也一律返回第 4 个包的 ACK。当发送端收到 3 个重复的 ACK 时，意识到丢包了，于是马上进行重传，不用等到一个 RTO 的时间到了才重传。

这就是**快速重传**，它解决的是**是否需要重传**的问题。

选择性重传：

在收到发送端的报文后，接收端回复一个 ACK 报文，那么在这个报文首部的可选项中，就可以加上`SACK`这个属性，通过`left edge`和`right edge`告知发送端已经收到了哪些区间的数据报。因此，即使第 5 个包丢包了，当收到第 6、7 个包之后，接收端依然会告诉发送端，这两个包到了。剩下第 5 个包没到，就重传这个包。这个过程也叫做**选择性重传(SACK，Selective Acknowledgment)**，它解决的是**如何重传**的问题。

快速恢复：

当然，发送端收到三次重复 ACK 之后，发现丢包，觉得现在的网络已经有些拥塞了，自己会进入**快速恢复**阶段。

在这个阶段，发送端如下改变：

- 拥塞阈值降低为 cwnd 的一半
- cwnd 的大小变为拥塞阈值
- cwnd 线性增加