#### 缓存

网络方面的缓存分为三块：`DNS缓存`、`HTTP缓存`、`CDN缓存`，也有人把这里的 **HTTP 缓存**称为**浏览器缓存**

还有本地的就是：浏览器的`本地存储`和`离线存储`，更快**提高首屏加载速度**，让页面飞起

##### DNS缓存

```
进入页面的时候会进行DNS查询，找到域名对应的服务器的IP地址，再发送请求

DNS域名查找先在客户端进行递归查询，如图
如果在本地DNS服务器没找到对应的IP
则继续向上级服务器查找，根域名服务器=>顶级域名服务器=>权威域名服务器

第一次进入页面的时候就把解析的ip缓存在浏览器，下次直接请求对应的地址
```

![image-20220401105251229](.\image\image-20220401105251229.png)

##### HTTP缓存

```
就是将http请求获取的页面资源存储在本地，之后再加载直接从缓存中获取而不用请求服务器，从而响应更快
```

![image-20220401105608842](.\image\image-20220401105608842.png)

##### CDN缓存

[进阶知识体系之你不能不知道的CDN](https://juejin.cn/post/6985816725098856479)

当我们发送一个请求时，浏览器本地缓存失效的情况下，CDN会帮我们去计算哪得到这些内容的路径短而且快。

比如在广州请求广州的服务器就比请求新疆的服务器响应速度快得多，然后向最近的CDN节点请求数据

CDN会判断缓存数据是否过期，如果没有过期，则直接将缓存数据返回给客户端，从而加快了响应速度。如果CDN判断缓存过期，就会向服务器发出回源请求，从服务器拉取最新数据，更新本地缓存，并将最新数据返回给客户端。

CDN不仅解决了跨运营商和跨地域访问的问题，大大降低访问延时的同时，还起到了分流的作用，减轻了源服务器的负载

##### 强缓存

```
第一次请求时，服务器把资源的过期时间通过响应头中的Expires和Cache-Control两个字段告诉浏览器，之后再请求这个资源的话，会判断有没有过期，没有过期就直接拿来用，不向服务器发起请求，这就是强缓存。

Expires(http/1.0)
用来指定资源到期时间，服务器响应时添加在响应头中 new Date()
expires: Wed, 22 Nov 2021 08:41:00 GMT
注意：如果服务器和浏览器端时间不一致的话可能导致失败。比如现在时间是8月1，expires过期时间是8月2，客户端把电脑时间改成了8月3，那就用不了这个缓存

Cache-Control(http/1.1)
指定资源过期时间秒，如下，表示在这个请求正确返回后的300秒内，资源可以使用，否则过期
cache-control:max-age=300

Cache-Control是关于浏览器缓存的最重要的设置，因为它覆盖其他设置，比如 Expires 和 Last-Modified。另外，由于浏览器的行为基本相同，这个属性是处理跨浏览器缓存问题的最有效的方法。

部分浏览器无法识别Cache-Control，Expires用作兼容，Cache-control优先级更高
```

![image-20220401110707268](.\image\image-20220401110707268.png)

![image-20220401110723395](.\image\image-20220401110723395.png)

###### 缺点

**就是缓存过期之后，不管资源有没有变化，都会重新发起请求，重新获取资源**

而我们希望的是在资源文件没有更新的情况下，即使过期了也不重新获取资源，继续使用旧资源

所以协商缓存它来了，在强缓存过期的情况下，再走协商缓存的流程，判断文件有没有更新

##### 协商缓存

第一次请求资源时，服务器除了会返回给浏览器上面说的过期时间，还会在响应头添加 `Last-Modified` 字段，告诉浏览器该资源的最后修改时间

```
last-modified: Fri, 27 Oct 2021 08:35:57 GMT
```

浏览器再次请求的时候就把这个时间再通过另一个字段`If-Modified-Since`，发送给服务器

```
if-modified-since: Fri, 27 Oct 2021 08:35:57 GMT
```

服务器再把这两个字段的时间对比，如果是一样的，就说明文件没有被更新过，就返回状态码304和空响应体给浏览器，浏览器直接拿过期了的资源继续使用即可；如果对比不一样说明资源有更新，就返回状态码200和新的资源，如图

![image-20220401112001943](.\image\image-20220401112001943.png)

###### 缺点

- ```
  如果本地打开了缓存文件，即使没有对文件进行修改，但还是会造成`Last-Modified`被修改，服务器端不能命中缓存导致发送相同资源
  
  因为`Last-Modified`只能以秒计时，如果在不可感知的时间内修改了文件，服务器端会认为还是命中了，无法返回正确的资源
  
  如果资源有周期性变化，如资源修改后，在一个周期内又改回了原来的样子，我们认为这个周期前的缓存是可以使用的，但是`Last-Modified`不这样认为
  ```

  

因为这些缺点，所以便有了另外一对 `ETag`/`If-None-Match`，用来对比文件内容(优先级更高)

第一次请求资源时，服务器除了会在响应头上返回`Expires`、`Cache-Control`、`Last-Modified`，还在返回`Etag`字段，表示当前资源文件的一个唯一标识。这个标识符由服务器基于文件内容编码生成，能精准感知文件的变化，只要文件内容不同，`ETag`就会重新生成

```
etag: W/"132489-1627839023000"
```

然后浏览器再次请求的时候就把这个文件标识 再通过另一个字段 `If-None-Match`，发送给服务器

```
if-none-match: W/"132489-1627839023000"
```

服务器再把这两个字段的时间对比，如果发现是一样的，就说明文件没有被更新过，就返回状态码304和空响应体给浏览器，浏览器直接拿过期了的资源继续使用；如果对比不一样说明资源有更新，就返回状态码200和新的资源

如果服务器又设置了Cache-Control:max-age和Expires呢，怎么办？

答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，服务器才能返回304.(不要陷入到底使用谁的问题怪圈)



**`Last-Modified 和 ETag 的区别`**

- `Etag` 感知文件精准度要高于 `Last-Modified`
- 同时使用时，服务器校验优先级 `Etag`/`If-None-Match`
- `Last-Modified` 性能上要优于 `Etag`，因为 `Etag` 生成过程中需要服务器付出额外开销，会影响服务器端的性能，所以它并不能完全替代 `Last-Modified`，只能作为补充和强化

##### 强缓存和协商缓存的区别

优先查找强缓存，没有命中再查找协商缓存

强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，资源是否有更新，服务器肯定知道

目前项目大多数使用缓存文案

1. 协商缓存一般存储：`HTML`
2. 强缓存一般存储：`css`, `image`, `js`，文件名带上 `hash`

hash和ETag区别?

##### 启发式缓存

就是响应中没有`Expires`，`Cache-Control：max-age`或`Cache-Control:s-maxage`，并且响应中不包含其他有关缓存的限制，缓存可以使用启发式方法计算缓存有效期

通常会根据响应头中的`Date`字段(报文创建时间)减去`Last-Modified`值的10%作为缓存时间

```
max(0,（Date - Last-Modified)) % 10
```

##### 缓存存放位置优先级

```
Service Worker > Memory Cache > Disk Cache > Push Cache
内存中的缓存在tab标签页关闭以后会释放
硬盘中的缓存，存储时间长，容量大，读取速度慢
```

